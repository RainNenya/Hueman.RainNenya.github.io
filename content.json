{"meta":{"title":"RainNenya","subtitle":null,"description":"RainNenya's blog","author":"Percy","url":"http://RainNenya.github.io"},"pages":[{"title":"about","date":"2019-02-15T05:49:30.000Z","updated":"2019-02-15T05:49:30.964Z","comments":true,"path":"about/index.html","permalink":"http://RainNenya.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"枚举的使用示例","slug":"枚举的使用示例","date":"2019-02-17T03:46:25.562Z","updated":"2019-02-17T05:54:51.248Z","comments":true,"path":"2019/02/17/枚举的使用示例/","link":"","permalink":"http://RainNenya.github.io/2019/02/17/枚举的使用示例/","excerpt":"枚举的使用示例(以性别为例)一、枚举的创建 枚举的创建包含数字型的状态码和与之对应的字符串型的消息（类似于HTTP响应中的响应码和响应消息）。","text":"枚举的使用示例(以性别为例)一、枚举的创建 枚举的创建包含数字型的状态码和与之对应的字符串型的消息（类似于HTTP响应中的响应码和响应消息）。 创建带参的构造函数。并生成get、set方法，此处略…… 二、创建获取消息的方法（getMsgByStatus） 在枚举中增加一个方法用于通过数字型的状态码获取对应的消息（类似于map中通过key来找value）。 三、枚举的使用 使用时将枚举看成一个类，枚举的每一个元素看成一个静态属性，通过枚举名引用。 增删改（DML）操作时取枚举元素的数字型状态属性，存入数据库。 查询时从数据库中取到之前存入的数字型状态属性，然后传入对应枚举中的getMsgByStatus方法（步骤2中自定义），获取字符串型的消息属性值用于显示即可。 四、GenderEnum1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public enum GenderEnum &#123; /** * 1 表示男 * 2 表示女 */ MALE(1, \"男\"), FEMALE(2, \"女\"); /** * 数字型的状态码 */ private int status; /** * 字符串型的消息 */ private String message; private GenderEnum(int status, String message) &#123; this.status = status; this.message = message; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; /** * 根据数字型的状态码(key) 获取字符串型的消息(value) * @param status 数字型的状态码(key) * @return 字符串型的消息(value) */ public static String getMsgByStatus(Integer status)&#123; GenderEnum[] enums = GenderEnum.values(); for (int i = 0; i &lt; enums.length; i++) &#123; return enums[i].getMessage(); &#125; return \"\"; &#125;&#125;","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"enumeration","slug":"enumeration","permalink":"http://RainNenya.github.io/tags/enumeration/"}]},{"title":"Java的8中基本数据类型","slug":"Java的8中基本数据类型","date":"2019-02-16T06:07:03.084Z","updated":"2019-02-17T02:33:30.144Z","comments":true,"path":"2019/02/16/Java的8中基本数据类型/","link":"","permalink":"http://RainNenya.github.io/2019/02/16/Java的8中基本数据类型/","excerpt":"一、什么是数据类型 百度百科: 数据类型在数据结构中的定义是一个值的集合以及定义在这个值集上的一组操作。变在声明变量时也可指定它的数据类型。所有变量都具有数据类型，以决定能够存储哪种数据。所以，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。","text":"一、什么是数据类型 百度百科: 数据类型在数据结构中的定义是一个值的集合以及定义在这个值集上的一组操作。变在声明变量时也可指定它的数据类型。所有变量都具有数据类型，以决定能够存储哪种数据。所以，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。 二、Java的基本数据类型 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 三、Java基本数据的大小，默认值和取值范围 序号 数据类型 位数 默认值 取值范围 1 byte(位) 8 0 -2^7 - 2^7-1 2 short(短整型) 16 0 -2^15 - 2^15-1 3 int(整型) 32 0 -2^31 - 2^31-1 4 long(长整型) 64 0 -2^63 - 2^63-1 5 float(单精度) 32 0.0 -2^31 - 2^31-1 6 double(双精度) 64 0.0 -2^63 - 2^63-1 7 char(字符) 16 空 0 - 2^16-1 8 boolean(布尔) false true - false 四、IDEA中验证基本数据的大小，默认值和取值范围123456789101112131415161718192021222324252627282930313233343536public class DataType &#123; static byte b; static short s; static int i; static long l; static float f; static double d; static char c; static boolean bool; public static void main(String args[]) &#123; System.out.println(\"byte[大小:\"+Byte.SIZE +\", 默认值:\"+b +\"; 数据范围:\"+Byte.MIN_VALUE+\" ~ \"+Byte.MAX_VALUE+\"]\"); System.out.println(\"short[大小:\"+Short.SIZE +\", 默认值:\"+s +\"; 数据范围:\"+Short.MIN_VALUE+\" ~ \"+Short.MAX_VALUE+\"]\"); System.out.println(\"int[大小:\"+Integer.SIZE +\", 默认值:\"+i +\"; 数据范围:\"+Integer.MIN_VALUE+\" ~ \"+Integer.MAX_VALUE+\"]\"); System.out.println(\"long[大小:\"+Long.SIZE +\", 默认值:\"+l +\"; 数据范围:\"+Long.MIN_VALUE+\" ~ \"+Long.MAX_VALUE+\"]\"); System.out.println(\"float[大小:\"+Float.SIZE +\", 默认值:\"+f +\"; 数据范围:\"+Float.MIN_VALUE+\" ~ \"+Float.MAX_VALUE+\"]\"); System.out.println(\"double[大小:\"+Double.SIZE +\", 默认值:\"+d +\"; 数据范围:\"+Double.MIN_VALUE+\" ~ \"+Double.MAX_VALUE+\"]\"); System.out.println(\"char[大小:\"+Character.SIZE +\", 默认值:\"+c +\"; 数据范围:\"+(int)Character.MIN_VALUE+\" ~ \"+(int)Character.MAX_VALUE+\"]\"); System.out.println(\"boolean[默认值:\"+bool +\"; 数据范围:\"+Boolean.TRUE+\" &amp; \"+Boolean.FALSE+\"]\"); &#125;&#125; 运行结果:","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[]},{"title":"初识Java多线程","slug":"初识Java多线程","date":"2019-01-27T13:40:00.203Z","updated":"2019-02-16T06:11:04.262Z","comments":true,"path":"2019/01/27/初识Java多线程/","link":"","permalink":"http://RainNenya.github.io/2019/01/27/初识Java多线程/","excerpt":"线程的概念和其两种实现方式一、程序、进程、线程の概念 1、程序：利用编程语言开发的一个工具软件， 静态的，在没有启动运行之前只是磁盘中的一个普通文件。 2、进程: 程序启动之后就变成了进程，进程是在内存中运行的，具有一定的生命周期，如果程序运行解析，进程在内存中就会回收，生命周期也就结束了，当然程序是可以再次运行，重写变成进程。 3、线程：进程在运行过程中的执行走向，线索。线程是比进程更小的一个单位，一个进程可以有一个或多个线程的。","text":"线程的概念和其两种实现方式一、程序、进程、线程の概念 1、程序：利用编程语言开发的一个工具软件， 静态的，在没有启动运行之前只是磁盘中的一个普通文件。 2、进程: 程序启动之后就变成了进程，进程是在内存中运行的，具有一定的生命周期，如果程序运行解析，进程在内存中就会回收，生命周期也就结束了，当然程序是可以再次运行，重写变成进程。 3、线程：进程在运行过程中的执行走向，线索。线程是比进程更小的一个单位，一个进程可以有一个或多个线程的。 二、线程的实现方法1.单线程java程序启动运行时，就自动产生了一个线程，主函数main就是在这个线程上运行的，当不再产生新的线程时，程序就是单线程。 123456789public class SingleThreaded &#123; public static void main(String args[]) &#123; //主线程 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+\" 第\"+i+\"次执行\"); &#125; System.out.println(Thread.currentThread().getName()+\" 线程死亡\"); &#125;&#125; 运行结果: main 第0次执行main 第1次执行main 第2次执行main 第3次执行main 第4次执行main 线程死亡 2.继承Thread类实现线程 1、继承 Thread 2、重写run方法 3、在主线程中通过start方法启动线程 12345678910public class Thread1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+\" 第\"+i+\"次执行\"); &#125; System.out.println(Thread.currentThread().getName()+\" 线程运行结束\"); &#125;&#125; 12345678public class ThreadDemo extends Thread &#123; public static void main(String args[]) &#123; Thread1 thread1 = new Thread1(); Thread1 thread2 = new Thread1(); thread1.start(); thread2.start(); &#125;&#125; 运行结果: Thread-1 第0次执行Thread-0 第0次执行Thread-1 第1次执行Thread-0 第1次执行Thread-1 第2次执行Thread-0 第2次执行Thread-1 第3次执行Thread-0 第3次执行Thread-1 第4次执行Thread-0 第4次执行Thread-1 线程运行结束Thread-0 线程运行结束 3.通过实现Runnable接口实现线程 实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910111213141516171819public class Thread2 &#123; public static void main(String args[]) &#123; //启动这个线程也有点区别，你需要new一个Thread类，并把这个实现类作为参数传入这个Thread类 MyRunnable myRunnable = new MyRunnable(); Thread thread1 = new Thread(myRunnable); Thread thread2 = new Thread(myRunnable); thread1.start(); thread2.start(); &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \"第\" + i +\"次执行\"); &#125; &#125;&#125; 运行结果: Thread-0第0次执行Thread-1第0次执行Thread-0第1次执行Thread-1第1次执行Thread-0第2次执行Thread-1第2次执行Thread-0第3次执行Thread-1第3次执行Thread-0第4次执行Thread-1第4次执行 三、Java线程的状态每个线程都有一个从初始状态到死亡状态的生命周期，其间根据业务流程经过就绪状态（runnable）、运行状态（running）、阻塞状态（blacked），这些状态可以根据流行需要相互转换。线程状态转换示意图: 初始状态跟其他Java对象一样用new语句创建的线程对象处于初始状态，此时仅被分配了内存。 就绪状态（Runnable）当每个线程对象创建好后，通过调用其start()方法使得该线程就进入就绪状态，就绪状态的线程进入到JVM的可运行池中等待CPU的使用权，每个线程都可以通过设置其优先级以提高取得CPU的使用权的可能性。当然，CPU的使用权跟计算机的硬件分不开的，这体现在单CPU环境下跟多CPU（及单CPU多核）下处理是不一样的，因为同一时刻可以让几个线程占用不同的CPU。 运行状态在JVM中就绪状态的线程取得CPU的使用权后，得以执行run()方法中定义的程序代码。只有处于就绪状态的线程才有机会转到运行状态。 阻塞状态（Blocked）运行中的线程可以根据需要放弃占用的CPU而暂停运行，这是线程就处于阻塞状态，此时Jvm不再尝试给线程分配CPU使用机会。 死亡状态（Deaded）当线程正常执行完run()方法中的代码，或者遇到异常未捕获造成中断，线程就会退出运行状态，转入死亡状态，结束其生命周期。 参考文章: Java总结篇系列：Java多线程（一）","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"multithreading","slug":"multithreading","permalink":"http://RainNenya.github.io/tags/multithreading/"}]}]}