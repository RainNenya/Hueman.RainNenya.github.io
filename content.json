{"meta":{"title":"RainNenya","subtitle":null,"description":"RainNenya's blog","author":"Percy","url":"http://RainNenya.github.io"},"pages":[{"title":"about","date":"2019-02-15T05:49:30.000Z","updated":"2019-02-15T05:49:30.964Z","comments":true,"path":"about/index.html","permalink":"http://RainNenya.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"初识Hibernate","slug":"初识Hibernate","date":"2019-02-27T03:27:00.823Z","updated":"2019-02-27T10:02:52.610Z","comments":true,"path":"2019/02/27/初识Hibernate/","link":"","permalink":"http://RainNenya.github.io/2019/02/27/初识Hibernate/","excerpt":"一、什么是Hibernate? Hibernate （开放源代码的对象关系映射框架）: Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。","text":"一、什么是Hibernate? Hibernate （开放源代码的对象关系映射框架）: Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 二、为什么使用Hibernate？2.1 Hibernate相对于传统JDBC的优点 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作。 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 2.2 Hibernate相对于MyBatis的区别与联系两者区别： 两者联系：缓存方面 相同点： Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓 存方案，创建适配器来完全覆盖缓存行为。 不同点： Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。 MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。 三、Hibernate的使用准备好User实体类和数据库记录 User.java 123456public class User &#123; private Integer id; private String userName; private String passWord; //Get、Set方法，此处省略。&#125; mysql数据库： 3.1 添加pom依赖Hibernate基础Maven依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加hibernate的依赖 开始--&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://mvnrepository.com/artifact/org.hibernate/hibernate --&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.2.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &amp;lt;!&amp;ndash; Hibernate library dependecy end &amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!-- 添加hibernate的依赖 结束--&gt; &lt;!-- mysql数据库的驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.2 hibernate.cfg.xml配置文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--&lt;property name=\"hibernate.bytecode.use_reflection_optimizer\"&gt;false&lt;/property&gt;--&gt; &lt;!--指定数据库的驱动程序--&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--指定连接数据库的口令--&gt; &lt;property name=\"hibernate.connection.password\"&gt;admin&lt;/property&gt; &lt;!--指定连接数据库的URL--&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/Hibernatetraning&lt;/property&gt; &lt;!--指定连接数据库的用户名--&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;!--数据库方言，用于指定使用的sql从属于哪个数据库--&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--如果为true，表示在程序运行时会在控制台输出SQL语句，有利于跟踪Hibernate的运行状态，默认为false。应用开发阶段设置为true，发布阶段应设置为false提高运行性能--&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;--&gt; &lt;mapping resource=\"mapper/User.hbm.xml\"&gt;&lt;/mapping&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 3.2 User.hbm.xml映射文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 4.0//EN\" \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.entity.User\" table=\"tbl_user\"&gt; &lt;!-- 在User里面 id 的set 和 get 方法里 也要设置为Integer类型的，不然会报错 --&gt; &lt;id name=\"id\" column=\"id\" type=\"java.lang.Integer\"&gt; &lt;generator class=\"assigned\"/&gt; &lt;/id&gt; &lt;property name=\"userName\" column=\"username\" type=\"java.lang.String\" length=\"20\" /&gt; &lt;property name=\"passWord\" column=\"password\" type=\"java.lang.String\" length=\"20\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试12345678910Configuration config = new Configuration().configure(); SessionFactory sessionFactory = config.buildSessionFactory(); //测试session是否创建，以及是否可以从user映射的表里获取记录 Session session = sessionFactory.openSession(); //System.out.println(\"session==\"+session); User user = (User)session.get(User.class,1); System.out.println(user);//关闭会话工厂，项目自动停止。生产环境中千万不要写这句。//sessionFactory.close(); 控制台输出：User{id=1, userName=’Jack’, passWord=’123’} 四、Hibernate基本概念 Hibernate是自动化程度更高ORM（Object-Relational Mapping）框架，不是面向SQL的持久层框架，以更加OO方式来编写数据读写代码。 4.1 对象与关系型数据库 注意：一定要清楚当前操作的东西，是属于对象层面的还是关系型数据库层面的，解决异常也是如此。 Hibernate中的对象有3中状态,瞬时对象(Transient Objects)、持久化对象(Persistent Objects)和离线对象(Detached Objects也叫做脱管对象)。 4.2 HibernateUtils.java工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class HibernateUtils &#123; private static SessionFactory sessionFactory = null; static &#123; try &#123; Configuration configuration = new Configuration().configure(); ServiceRegistry serviceRegistry = new ServiceRegistryBuilder() .applySettings(configuration.getProperties()) .build(); sessionFactory = configuration.buildSessionFactory(serviceRegistry); &#125;catch (HibernateException e)&#123; System.out.println(\"SessionFactory初始化失败\"); e.printStackTrace(); &#125; &#125; public static SessionFactory getSessionFactory() throws Exception&#123; if (sessionFactory != null)&#123; return sessionFactory; &#125;else &#123; throw new Exception(\"sessionFactory为空，请检查配置文件\"); &#125; &#125; public static Session getSession()&#123; Session session = null; try &#123; if (sessionFactory != null)&#123; session = sessionFactory.openSession(); &#125; &#125;catch (HibernateException e)&#123; e.printStackTrace(); &#125; return session; &#125; public static void closeSession(Session session)&#123; try &#123; if (session != null &amp;&amp; session.isOpen())&#123; session.close(); &#125; &#125;catch (HibernateException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 4.3 瞬时对象与持久化对象测试代码： 12345678910111213141516Session session = HibernateUtils.getSession(); Transaction tx = session.beginTransaction(); User user1 = new User(); user1.setId(2); user1.setUserName(\"Frank\"); user1.setPassWord(\"111\"); // 当前user1在数据库中没有记录进行关联，所有此时user1是瞬时对象。// 将user1持久化 session.save(user1); tx.commit(); User user2 = (User)session.get(User.class, 2); System.out.println(user2); // 当前user2在数据库有唯一一条记录对应，所有此时user2是持久化对象。 4.4 hibernate.hbm2ddl.autohibernate.hbm2ddl.auto属性值（从类自动生成数据库DDL操作） &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; create：如果设置为该值，则每次加载hibernate时（准确说应是创建SessionFactory时）都会删除以前创建的表而根据model重新生成表，即使前后的表没有任何变化，通常会造成数据库数据丢失，需谨慎使用这个取值。 create-drop：与create差不多，所不同的是每次sessionFactory关闭时，就会删除所有表。 update（最常用）：这个取值比较常用，需要先建立数据库，在第一次加载hibernate时会自动创建表，以后创建hibernate会自动根据model更新表结构，即使表结构改变了，以前的行不会被删除。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"http://RainNenya.github.io/tags/ORM/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://RainNenya.github.io/tags/Hibernate/"}]},{"title":"SpringMVC常用客户端参数接收方式","slug":"SpringMVC常用客户端参数接收方式","date":"2019-02-20T13:28:13.795Z","updated":"2019-02-27T09:52:04.086Z","comments":true,"path":"2019/02/20/SpringMVC常用客户端参数接收方式/","link":"","permalink":"http://RainNenya.github.io/2019/02/20/SpringMVC常用客户端参数接收方式/","excerpt":"在MVC结构中，控制器组件主要的功能就是接收请求、处理请求、生成响应，接收客户端传来的请求参数的往往是控制器要做的第一件事。","text":"在MVC结构中，控制器组件主要的功能就是接收请求、处理请求、生成响应，接收客户端传来的请求参数的往往是控制器要做的第一件事。 Book实体类Book.java 12345public class Book &#123; private Integer bookId; private String author; //生成Get、Set方法，此处省略&#125; 一、直接用参数名匹配请求参数客户端界面（表单）: 12345&lt;form action=\"/queryString\" method=\"post\"&gt; &lt;input type=\"text\" name=\"bookId\"&gt; &lt;input type=\"text\" name=\"author\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; controller层： 123456789@Controllerpublic class ParamPassDemo &#123; @RequestMapping(value=\"/queryString\") public String test1(Integer bookId, String author) &#123; System.out.println(\"bookId=\"+bookId+\", author=\"+author); //此处返回的地址为（/WEB-INF/jsp/index.jsp） return \"index\"; &#125;&#125; 注意：这里@RequestMapping中只有value属性，value可以省略不写。 客户端输入：123,Rose 控制台输出：bookId=123, author=Rose 二、通过@RequestParam注解来指定请求参数的name客户端界面（表单）: 12345&lt;form action=\"/queryStringWithSpecName\" method=\"post\"&gt; &lt;input type=\"text\" name=\"bookId\" value=\"321\"&gt; &lt;input type=\"text\" name=\"author\" value=\"Jack\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 如果表单中的字段与方法中的参数名一致，可以不需要@RequestParam，Spring会自动处理。 controller层： 12345678@Controllerpublic class ParamPassDemo &#123; @RequestMapping(\"/queryStringWithSpecName\") public String test2((value=\"bookId\",required=false) Integer id, @RequestParam(\"author\") String name) &#123; System.out.println(\"bookId=\"+id+\", author=\"+name); return \"index\"; &#125;&#125; 注意：这里@RequestParam中有两个属性，value不能省略。 @RequestParam将请求地址中的参数传递给目标方法，在处理方法入参处使用可以把请求参数传递给请求方法。 当使用@RequestParam注解时，设置客户端传递的请求参数name=&quot;bookId&quot;和@RequestParam的value值value=&quot;bookId&quot;相匹配后，参数名int id可以和请求参数不匹配。 客户端输入：321, Jack 控制台输出：bookId=321, author=Jack 客户端界面（ajax）: 12345678910111213&lt;button onclick=\"clickMe()\"&gt;点我&lt;/button&gt;&lt;script&gt; function clickMe() &#123; $.ajax(&#123; type : 'POST', url : \"/queryStringWithSpecName\", data : &#123; \"bookId\" : 1, \"author\" : \"Jack\" &#125;, &#125;); &#125;&lt;/script&gt; controller层：（不变） 客户端: data:{“author” : “Jack”} 控制台输出: bookId=null, author=Jack（如果bookId为int类型，控制台会抛出异常） 客户端: data:{“bookId” : 1} 控制台输出: org.springframework.web.bind.MissingServletRequestParameterException: Required String parameter ‘author’ is not present 通过required设置可选参数，required为false时表示可以不带参数，为true时表示必须带参数（默认值为true）。 当可选参数不存在时，Spring默认将其赋值为空（null），但由于bookId已定义为基本类型int，所以赋值会失败。解决方法：采用int包装类Integer。 三、使用领域对象来接收参数客户端界面（表单）: 12345&lt;form action=\"/queryStringWithDomainObj\" method=\"post\"&gt; &lt;input type=\"text\" name=\"bookId\"&gt; &lt;input type=\"text\" name=\"author\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; controller层： 12345678@Controllerpublic class ParamPassDemo &#123; @RequestMapping(\"/queryStringWithDomainObj\") public String test3(Book book) &#123; System.out.println(\"bookId=\"+book.getBookId()+\", author=\"+book.getAuthor()); return \"index\"; &#125; &#125; 客户端输入：111, Bob 控制台输出：bookId=111, author=Bob 四、URL动态参数传递（路径参数）客户端界面（超链接）: 1&lt;a href=\"/book/1\"&gt;testPathVariable&lt;/a&gt; controller层： 123456789@Controllerpublic class ParamPassDemo &#123; //@PathVariable可以用来映射URL中的占位符到目标方法的参数中 @RequestMapping(\"/book/&#123;bookId&#125;\") public String test4(@PathVariable(\"bookId\") Integer bookId) &#123; System.out.println(\"bookId:\" + bookId); return \"index\"; &#125; &#125; 控制台输出：bookId:1 @PathVariable 映射 URL 绑定的占位符 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 五、使用HttpServletRequest获取请求参数客户端界面（表单）: 12345&lt;form action=\"/queryBook\" method=\"post\"&gt; &lt;input type=\"text\" name=\"bookId\"&gt; &lt;input type=\"text\" name=\"author\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; controller层： 123456789@Controllerpublic class ParamPassDemo &#123; @RequestMapping(\"/queryBook\") public String test5(HttpServletRequest request) &#123; System.out.println(\"bookId:\" + request.getParameter(\"bookId\")); //此处index.jsp界面在WEB-INF下 return \"redirect:/index.jsp\"; &#125; &#125; 客户端输入：123 控制台输出：用户id:123 六、跳转到另一个controller方法客户端界面（url地址栏）: 1http://localhost:8080/test6?bookId=321 controller层： 12345678910@Controllerpublic class ParamPassDemo &#123; @RequestMapping(\"/test6\") public String test6(String bookId)&#123; System.out.println(\"bookId=\"+bookId); //使用服务端跳转的方式转向到另一个controller //return \"forward:queryBook?bookId=\"+bookId; return \"redirect:queryUser?bookId=\"+bookId; &#125; &#125; 控制台输出：bookId=321 bookId:321","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://RainNenya.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://RainNenya.github.io/tags/SpringMVC/"}]},{"title":"分页插件PageHelper","slug":"分页插件PageHelper","date":"2019-02-19T01:09:02.351Z","updated":"2019-02-27T10:08:17.513Z","comments":true,"path":"2019/02/19/分页插件PageHelper/","link":"","permalink":"http://RainNenya.github.io/2019/02/19/分页插件PageHelper/","excerpt":"如果你也在用 MyBatis，建议尝试该分页插件，这一定是最方便使用的分页插件。分页插件支持任何复杂的单表、多表分页。 PageHelper是一个Mybatis的分页插件, 负责将已经写好的sql语句, 进行分页加工.","text":"如果你也在用 MyBatis，建议尝试该分页插件，这一定是最方便使用的分页插件。分页插件支持任何复杂的单表、多表分页。 PageHelper是一个Mybatis的分页插件, 负责将已经写好的sql语句, 进行分页加工. PageHelper的使用 优点：无需你自己去封装以及关心sql分页等问题，使用很方便，前端取数据也很方便。 1.引入pagehelper依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;ersion&gt;&lt;/dependency&gt; 2.配置applicationContext.xml文件 在spring的sqlsessionfactory的bean中增加一个分页拦截器属性 1234567891011121314&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;property name=\"properties\"&gt; &lt;value&gt; &lt;!-- 这里设定你的数据库类型 --&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 3.调用PageHelper的方法 在service方法中调用PageHelper的静态方法startPage（注意一定要在实际查询数据库之前调用该方法）,传入需要查询的页号和每页大小，返回PageHelper插件提供的PageInfo对象。即可自动完成数据库物理分页，无须在你的sql语句中手工加limit子句 4. PageInfo的结构 关于PageInfo的结构请参看源码，这里通过返回的json来展示。根据需要取PageInfo对象的相应属性即可。","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://RainNenya.github.io/tags/MyBatis/"}]},{"title":"枚举的使用示例","slug":"枚举的使用示例","date":"2019-02-17T03:46:25.562Z","updated":"2019-02-27T10:09:11.507Z","comments":true,"path":"2019/02/17/枚举的使用示例/","link":"","permalink":"http://RainNenya.github.io/2019/02/17/枚举的使用示例/","excerpt":"一、枚举的创建（以性别为例） 枚举的创建包含数字型的状态码和与之对应的字符串型的消息（类似于HTTP响应中的响应码和响应消息）。","text":"一、枚举的创建（以性别为例） 枚举的创建包含数字型的状态码和与之对应的字符串型的消息（类似于HTTP响应中的响应码和响应消息）。 创建带参的构造函数。并生成get、set方法，此处略…… 二、创建获取消息的方法（getMsgByStatus） 在枚举中增加一个方法用于通过数字型的状态码获取对应的消息（类似于map中通过key来找value）。 三、枚举的使用 使用时将枚举看成一个类，枚举的每一个元素看成一个静态属性，通过枚举名引用。 增删改（DML）操作时取枚举元素的数字型状态属性，存入数据库。 查询时从数据库中取到之前存入的数字型状态属性，然后传入对应枚举中的getMsgByStatus方法（步骤2中自定义），获取字符串型的消息属性值用于显示即可。 四、GenderEnum1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public enum GenderEnum &#123; /** * 1 表示男 * 2 表示女 */ MALE(1, \"男\"), FEMALE(2, \"女\"); /** * 数字型的状态码 */ private int status; /** * 字符串型的消息 */ private String message; private GenderEnum(int status, String message) &#123; this.status = status; this.message = message; &#125; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; /** * 根据数字型的状态码(key) 获取字符串型的消息(value) * @param status 数字型的状态码(key) * @return 字符串型的消息(value) */ public static String getMsgByStatus(Integer status)&#123; GenderEnum[] enums = GenderEnum.values(); for (int i = 0; i &lt; enums.length; i++) &#123; return enums[i].getMessage(); &#125; return \"\"; &#125;&#125;","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"enumeration","slug":"enumeration","permalink":"http://RainNenya.github.io/tags/enumeration/"}]},{"title":"Java的8中基本数据类型","slug":"Java的8中基本数据类型","date":"2019-02-16T06:07:03.084Z","updated":"2019-02-17T02:33:30.144Z","comments":true,"path":"2019/02/16/Java的8中基本数据类型/","link":"","permalink":"http://RainNenya.github.io/2019/02/16/Java的8中基本数据类型/","excerpt":"一、什么是数据类型 百度百科: 数据类型在数据结构中的定义是一个值的集合以及定义在这个值集上的一组操作。变在声明变量时也可指定它的数据类型。所有变量都具有数据类型，以决定能够存储哪种数据。所以，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。","text":"一、什么是数据类型 百度百科: 数据类型在数据结构中的定义是一个值的集合以及定义在这个值集上的一组操作。变在声明变量时也可指定它的数据类型。所有变量都具有数据类型，以决定能够存储哪种数据。所以，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。 二、Java的基本数据类型 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 三、Java基本数据的大小，默认值和取值范围 序号 数据类型 位数 默认值 取值范围 1 byte(位) 8 0 -2^7 - 2^7-1 2 short(短整型) 16 0 -2^15 - 2^15-1 3 int(整型) 32 0 -2^31 - 2^31-1 4 long(长整型) 64 0 -2^63 - 2^63-1 5 float(单精度) 32 0.0 -2^31 - 2^31-1 6 double(双精度) 64 0.0 -2^63 - 2^63-1 7 char(字符) 16 空 0 - 2^16-1 8 boolean(布尔) false true - false 四、IDEA中验证基本数据的大小，默认值和取值范围123456789101112131415161718192021222324252627282930313233343536public class DataType &#123; static byte b; static short s; static int i; static long l; static float f; static double d; static char c; static boolean bool; public static void main(String args[]) &#123; System.out.println(\"byte[大小:\"+Byte.SIZE +\", 默认值:\"+b +\"; 数据范围:\"+Byte.MIN_VALUE+\" ~ \"+Byte.MAX_VALUE+\"]\"); System.out.println(\"short[大小:\"+Short.SIZE +\", 默认值:\"+s +\"; 数据范围:\"+Short.MIN_VALUE+\" ~ \"+Short.MAX_VALUE+\"]\"); System.out.println(\"int[大小:\"+Integer.SIZE +\", 默认值:\"+i +\"; 数据范围:\"+Integer.MIN_VALUE+\" ~ \"+Integer.MAX_VALUE+\"]\"); System.out.println(\"long[大小:\"+Long.SIZE +\", 默认值:\"+l +\"; 数据范围:\"+Long.MIN_VALUE+\" ~ \"+Long.MAX_VALUE+\"]\"); System.out.println(\"float[大小:\"+Float.SIZE +\", 默认值:\"+f +\"; 数据范围:\"+Float.MIN_VALUE+\" ~ \"+Float.MAX_VALUE+\"]\"); System.out.println(\"double[大小:\"+Double.SIZE +\", 默认值:\"+d +\"; 数据范围:\"+Double.MIN_VALUE+\" ~ \"+Double.MAX_VALUE+\"]\"); System.out.println(\"char[大小:\"+Character.SIZE +\", 默认值:\"+c +\"; 数据范围:\"+(int)Character.MIN_VALUE+\" ~ \"+(int)Character.MAX_VALUE+\"]\"); System.out.println(\"boolean[默认值:\"+bool +\"; 数据范围:\"+Boolean.TRUE+\" &amp; \"+Boolean.FALSE+\"]\"); &#125;&#125; 运行结果:","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[]},{"title":"初识Java多线程","slug":"初识Java多线程","date":"2019-01-27T13:40:00.203Z","updated":"2019-02-27T10:07:48.048Z","comments":true,"path":"2019/01/27/初识Java多线程/","link":"","permalink":"http://RainNenya.github.io/2019/01/27/初识Java多线程/","excerpt":"一、程序、进程、线程の概念 1、程序：利用编程语言开发的一个工具软件， 静态的，在没有启动运行之前只是磁盘中的一个普通文件。 2、进程: 程序启动之后就变成了进程，进程是在内存中运行的，具有一定的生命周期，如果程序运行解析，进程在内存中就会回收，生命周期也就结束了，当然程序是可以再次运行，重写变成进程。 3、线程：进程在运行过程中的执行走向，线索。线程是比进程更小的一个单位，一个进程可以有一个或多个线程的。","text":"一、程序、进程、线程の概念 1、程序：利用编程语言开发的一个工具软件， 静态的，在没有启动运行之前只是磁盘中的一个普通文件。 2、进程: 程序启动之后就变成了进程，进程是在内存中运行的，具有一定的生命周期，如果程序运行解析，进程在内存中就会回收，生命周期也就结束了，当然程序是可以再次运行，重写变成进程。 3、线程：进程在运行过程中的执行走向，线索。线程是比进程更小的一个单位，一个进程可以有一个或多个线程的。 二、线程的实现方法1.单线程java程序启动运行时，就自动产生了一个线程，主函数main就是在这个线程上运行的，当不再产生新的线程时，程序就是单线程。 123456789public class SingleThreaded &#123; public static void main(String args[]) &#123; //主线程 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+\" 第\"+i+\"次执行\"); &#125; System.out.println(Thread.currentThread().getName()+\" 线程死亡\"); &#125;&#125; 运行结果: main 第0次执行main 第1次执行main 第2次执行main 第3次执行main 第4次执行main 线程死亡 2.继承Thread类实现线程 1、继承 Thread 2、重写run方法 3、在主线程中通过start方法启动线程 12345678910public class Thread1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+\" 第\"+i+\"次执行\"); &#125; System.out.println(Thread.currentThread().getName()+\" 线程运行结束\"); &#125;&#125; 12345678public class ThreadDemo extends Thread &#123; public static void main(String args[]) &#123; Thread1 thread1 = new Thread1(); Thread1 thread2 = new Thread1(); thread1.start(); thread2.start(); &#125;&#125; 运行结果: Thread-1 第0次执行Thread-0 第0次执行Thread-1 第1次执行Thread-0 第1次执行Thread-1 第2次执行Thread-0 第2次执行Thread-1 第3次执行Thread-0 第3次执行Thread-1 第4次执行Thread-0 第4次执行Thread-1 线程运行结束Thread-0 线程运行结束 3.通过实现Runnable接口实现线程 实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910111213141516171819public class Thread2 &#123; public static void main(String args[]) &#123; //启动这个线程也有点区别，你需要new一个Thread类，并把这个实现类作为参数传入这个Thread类 MyRunnable myRunnable = new MyRunnable(); Thread thread1 = new Thread(myRunnable); Thread thread2 = new Thread(myRunnable); thread1.start(); thread2.start(); &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + \"第\" + i +\"次执行\"); &#125; &#125;&#125; 运行结果: Thread-0第0次执行Thread-1第0次执行Thread-0第1次执行Thread-1第1次执行Thread-0第2次执行Thread-1第2次执行Thread-0第3次执行Thread-1第3次执行Thread-0第4次执行Thread-1第4次执行 三、Java线程的状态每个线程都有一个从初始状态到死亡状态的生命周期，其间根据业务流程经过就绪状态（runnable）、运行状态（running）、阻塞状态（blacked），这些状态可以根据流行需要相互转换。线程状态转换示意图: 初始状态跟其他Java对象一样用new语句创建的线程对象处于初始状态，此时仅被分配了内存。 就绪状态（Runnable）当每个线程对象创建好后，通过调用其start()方法使得该线程就进入就绪状态，就绪状态的线程进入到JVM的可运行池中等待CPU的使用权，每个线程都可以通过设置其优先级以提高取得CPU的使用权的可能性。当然，CPU的使用权跟计算机的硬件分不开的，这体现在单CPU环境下跟多CPU（及单CPU多核）下处理是不一样的，因为同一时刻可以让几个线程占用不同的CPU。 运行状态在JVM中就绪状态的线程取得CPU的使用权后，得以执行run()方法中定义的程序代码。只有处于就绪状态的线程才有机会转到运行状态。 阻塞状态（Blocked）运行中的线程可以根据需要放弃占用的CPU而暂停运行，这是线程就处于阻塞状态，此时Jvm不再尝试给线程分配CPU使用机会。 死亡状态（Deaded）当线程正常执行完run()方法中的代码，或者遇到异常未捕获造成中断，线程就会退出运行状态，转入死亡状态，结束其生命周期。 参考文章: Java总结篇系列：Java多线程（一）","categories":[{"name":"日常技术","slug":"日常技术","permalink":"http://RainNenya.github.io/categories/日常技术/"},{"name":"Java","slug":"日常技术/Java","permalink":"http://RainNenya.github.io/categories/日常技术/Java/"}],"tags":[{"name":"multithreading","slug":"multithreading","permalink":"http://RainNenya.github.io/tags/multithreading/"}]}]}